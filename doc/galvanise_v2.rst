galvanise v2
============
First off it is written in a mixture of python/c++.  The python side is using a PyPy interpreter,
and uses adhoc CFFI bindings to interface to c++ when needed.  The networking code utilizes the
twisted framework and although there a far from enough tests, the py.test framework is used.

There are no dependencies on the c++ side.  I am using c++11 and gcc with as much optimizations
turned on as possible.  I say c++, but I am not a huge fan or very skilled in the language.  So
yup, very far off the beat and track of what you'd normally see in modern c++ idiomatic code, c
with classes might be more accurate.

ggp-base is still used to generate a basic propnet description (thankyou!), and then a number of
optimizations and breaking up the propnet is all done in python.  A basic state machine
implementation is in python, but the real implementation is done in c++ and has python bindings.

During meta time, some analysis is done in python to decide what type of game it is, how the base
states are flipping for example, whether the game is simultaneous, factorable, whether there are
pieces that are being captured, and so on.  This was all thrown together in the month before the
competition and largely a starting point for future work.

From there we decide on a main search strategy (vanilla UCT MCTS, simultaneous MCTS, rave MCTS) and
whether to deploy a special rollout policy.

For the remainder of the game - we are in c++ for searching and python for match management.

The state machine has a low level interface (no memory allocated at any point) and completely
triggered based on any type of update.  That means, transitions and legals are updated only when
needed and no copying anything in or out of the state machine.  My findings were to squeeze that
final % performance increase, was to update the propnet statein a way that triggers the least.  So
this may involve splitting the propnet into separate smaller networks, so that legals don't flip on
and off (so for example in amazons, the network is split 4 ways: player 1 queen moves, player 1
fires, player 2 queen moves, player 2 fire).  An interesting one was not to flip the input
propositions on/off - ie keep one alive at all times, this can large n-fold increases in some
games.

There is a small interpreter in the statemachine to do the propagation, which has inlined code
depending on the number of outputs to be triggered.  The ordering of basic blocks generated by the
compiler are forced in way that follow the common code path (about 90% of the time, ie when there
are no triggers).  Ultimately, the implementation has quite a large overlap with Sancho's propnet
statemachine, which since they documented in detail and seems to be the fastest way to propagate
(at this point in time) - it made it very hard to do anything else.  Nevertheless, I experimented a
bit with some hybrid propnet/state machines and still think if given more meta-timing games such as
speed chess could get an order of magnitude faster via splitting the network up some more, and
generating code to replace some of the propnet.

For 1 and 2 player non-simultaneous games, galvanise is threaded.  A single thread is designated to
select from the tree, and to update the tree.  Node expansion and rollouts are done in worker
threads.  How backprop and selection is done, is dependent on what the search strategy is.


I'll focus on the rave search strategy, as it was used in 95% of games in the international
competition.  Most players these days are doing roughly the same thing, so I'll just enumerate them
here.

* a fast propnet
* some form of mcts (selection/expansion/simulation/backprop)
* a solver, which short circuits mcts towards the end of the game
* transpositions of nodes for game states


The rave strategy uses UCB1, as opposed to anything fancier.  Each node has its own UCB constant,
which dynamically adjusts based on the distribution of selections for that node (nothing fancy just
a few if/elses).  Each node selection starts with a number of random selections.  Which is
configurable (but 4 seems like a magic number).

After the random selection, the rave values are used and UCB constant is very low.  If it looks as
if distribution of rave updates is not spread evenly, the dynamic UCB is increased significantly,
and for that node it is now running more like plain UCT.  The rave back propagation is dynamic, and
if it is slowing down the search too much (ie if the rollout worker theads are completely
starved) - it will change how deep to update the rave values.  Also note there is some progressive
widening, which is a WIP - and doesn't follow other implementation I know of.  It just restricts
the exploration part of UCB score for any unexpanded nodes until n visits of the parent node.
Although WIP, it was enabled for the competition

On node expansion, the previous rave values are used if available for node initialization.  If
piece detection is enabled, then a bonus is given to captures.  The game depth is tracked, and if
game termination is expected soon - then will do a one step lookahead looking for terminal states -
and if so expanding them too.

Finally we have rollout policies.  This is chosen during meta-time from python.  They are actually
very simple and there isn't much to say here.  They are either one of the following, or some
combination of.

* one step lookahead for final states (*)
* MAST (as per Cadia-player)
* piece capturing, which returns a fabricated score and uses early cutoffs (only enabled in a few games).


Also, I should add for anyone that is interested, that for the competition galvanise ran on a
rented AWS server.  The main advantage and reason for doing so was I worried about timing out from
the UK (funny how everyone timed out anyway) It ran with 1 main thread, and 7 worker threads.  The
underlying machine is a hyper threaded single cpu xeon.  With the exception of hex, most of the
worker threads were stalled at 15-70%.


*Thanks for reading!*

Updates:


(*) one step lookahead policy is misleading.  It actually is one step and a good bit.  If it looks
like the one step lookahead is a win, then we backup to previous state.  If that backed up state is
the opponents, the opponent will discard the move it tried, and try another.  This will repeat
until no moves are left.  The idea here is the opponent will play a defensive move if available, to
prevent the win.  Secondly, we detect killer moves during the analysis, which are the same as
galvanise v1.  These are moves that always win (like in all breakthrough games).  Therefore, this
speeds up this policy greatly.

There was no mentioning of factoring.  This is because of the way splitting of the networks
works. galvanise largely got it for free.  Networks are split by looking for control states.  The
usual pattern is A -> B -> A.  Or in the case of say pentago : A -> B -> C -> D -> A.  For all
simultaneous games that galvanise can factor, if it detects two disparate groups (A -> B -> A and C
-> D -> C), then it still splits the network in four.  But at the top level in python, it creates
two separate search strategies - which is just like two independent games.  So there is no custom
c++ code for factorizing at all.
